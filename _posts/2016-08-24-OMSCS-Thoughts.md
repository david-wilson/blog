---
layout: blog
title: "Georgia Tech's OMSCS Program: Thoughts from an (Almost) Graduate"
---

In August 2014, I enrolled in Georgia Tech's Online Master's of Science in Computer Science program [(OMSCS)](https://www.omscs.gatech.edu/). If all goes well, I will graduate from the program at the end of this semester. Given this, I felt this would be a good time to share some of my thoughts and experiences with the program while it's all still fresh in my mind.

## The Why

My undergraduate degree is in geophysics rather than computer science. However, I have worked in software for my entire career (including college internships). Working as a developer making geophysical software, I quickly realized that getting a more solid grounding in basic computer science concepts, as well as some more advanced topics, would be beneficial to my career.

Initially, I considered the self-taught route. This works well for me for learning specific technologies, languages, and frameworks, but less well for theory heavy topics. For these concepts, I benefit from the structure of a formal class, as well as the strong incentives to stay on task due to the rigorous assessments.

When I first saw OMSCS program announcement, I was very intrigued. While I had some worries as to perceived market value of the online credential, I quickly realized that this was irrelevant for my actual educational needs. Given the low price of the program, I didn't need to justify a pure economic return, but rather the potential educational outcome given my time input. This was an easy decision for me. I applied for the second cohort, was accepted, and began that fall semester.

## First Impressions

My first class was Machine Learning, taught by Charles Isbell and Michael Littmann. This class introduced me to general OMSCS class logistics formula. The "learning environment" consists of:

- Udacity, for hosting the video lectures and inline quizzes
- Piazza, a message board software for class discussions
- T-Square, an internal GA Tech tool hosting class resources and submitting assignments

My first impressions of the lectures delivered via Udacity were very positive. As someone with a hearing impairment, I appreciated the ability to pause, rewind, and rewatch the lectures as often as needed. The inline quizzes helped keep me engaged with the lecture, as well.

The discussion system, Piazza, works fairly well, but is far from perfect. While it's easy to post a question, the sheer number of people in the classes can make it a noisy place. There are filter and following tools, but it's still easy to miss something unless you're checking it very often.

Office hours, an important part of the higher education learning experience, are obviously quite different when conducted online. Machine Learning used Google's Hangouts on Air, with the TA answering written questions. While this allowed for easy navigation of the office hours afterwards, this makes it difficult to ask follow up questions while keeping the thread of conversation consistent. However, the effort to make some sort of office hours available was greatly appreciated, even if there are scaling issues.

The assessments for machine learning consisted mostly of two exams and several projects. Most MOOCs (which OMSCS gets lumped in with, despite not being open or that massive) often fall flat with the assessments provided. They are often simple multiple choice quizzes that are easily passed via trial and error. I was very glad to see that the ML assessments were in no way lightweight. The projects were very substantial, requiring careful interpretation of the requirements, and lots of careful work to complete. These projects were time consuming, giving the ML class it's well deserved reputation as a heavy course. While some homeworks later in the program would be machine graded to some extent, all of these projects were hand graded, though perhaps with lighter feedback than I would ideally want.

The exams were fairly deep, without being impossible. The biggest gripe I had with them was the use of an online proctoring system that was buggy, invasive, and just generally unreliable. I understand preventing cheating is important, but online proctoring isn't a great experience compared to taking a test in a real classroom or testing center. The program  has since switched to a less fussy system, and that has improved the experience somewhat.

On the whole, though, ML was a great first class that gave me a strong theoretical background while introducing me to the mechanics of a typical OMSCS course.

## Side Channels

I covered the "official" class delivery channels in the previous section, but no discussion of the OMSCS experience would be complete without discussing some of the unofficial resources that have cropped up around the program. The biggest such resource is the OMSCS Google+ group, which is a hub of stickied resources, broad program discussion, and general outrage and worry during registration times. Professors, TAs, and admin officials frequent the group, making it almost feel like an extension of the official e-mail lists.

Like other OMSCS communication channels, it too suffers from a noise problem. However, sub-communities have branched off from the main group, including regional groups that allow students in the same geographic region to connect. I have had the pleasure of meeting, studying, and drinking beer with several other OMSCS students as a result of my local group, which adds a much needed personal element to the experience.

While Piazza carries most of the class discussions, it doesn't work well for real-time collaboration. A Hipchat (and later Slack) group exists for this purpose, allowing for students to quickly connect with each other and answer questions, form study groups, or engage in general "water cooler" chat. I've personally gotten a lot out of the Hipchat/Slack groups, and hope they continue as the program grows.

## The Trough of Sorrow

After successfully completing Machine Learning, I was excited to take two classes for spring: Computer Vision (CV) and Computability, Complexity, and Algorithms. CV was a brand new class for the semester, typically a red flag in terms of workload due to kinks in the class implementation, but since the topic is one that greatly interests me, I decided to dive in head first. CCA is a core class to the program, with famously difficult material, especially for folks without a very solid CS or discrete math background (such as myself).

CV proved to be one of the best courses I've ever taken, providing a well-grounded overview of the field, with well thought out exercises that had me implementing CV algorithms from the ground up. A great class, but also a very time consuming one. It was all I could do to keep up with each assignment, while resisting the urge to endlessly tune my implementations to get better results, which could be an even bigger time sink.

I was having so much fun with CV that CCA quickly began to feel like a chore. It didn't help that the terminology and math notation used by the class seemed utterly unfamiliar to me. After struggling through the first few problem sets, I realized that I had underestimated the class. Working furiously between CV assignments, I worked to understand the discrete mathematics and formal proofs required by the class. Each problem in the homeworks required reaching a specific "ah-ha!" moment that could take an indeterminate amount of time to reach. Still, I persisted.

After the first CCA midterm, I realized that I was in trouble. With a poor score on the test, I need to make a change. I first attempted to understand the reason I missed each point on the exam. Working through the TA's feedback, I was able to spot most of my logic errors. There was one problem, though, involving reducing a problem to an NP Complete problem, that I could not spot my logic error on. After a few back and forths with the TA, where it felt like we were just talking past each other, I had to give up on understanding where I'd gone wrong in the interests of moving forward. This was hugely demoralizing, and the moment where I most missed having "real" classmates nearby, to stay up late and work through tough problems, as I had experienced in my undergrad classes.  I considered hiring a tutor to help, but tutors for this subject are hard to come by.

In the end, I finished well with CV, and not so well in CCA. After an incredibly busy and stressful semester, I hoped for a bit of a lighter load for the summer.

## Cruise Mode

I got my wish. Knowledge Based AI was my summer class, an interesting if not totally rigorous introduction cognitive concepts in artificial intelligence. This class was run by David Joyner, an instructor with the program who has a clear passion for the process of designing and administering a class. Every aspect of the class ran like clockwork, which was very refreshing.

Fall was Introduction to Operating Systems (IOS) and Educational Technology (EdTech). IOS is one of the best classes in the program, providing a great overview of OS concepts, with exercises that challenged my systems programming skills (all low level C) while not being so complex as to feel impossible. EdTech was a project based class, where I implemented a series of reading text classifiers to help label texts for elementary teachers. While I did learn a lot from this project, I realized I could have done much better with a more solid introduction to NLP techniques than I was able to research while implementing the tool.

Spring (now 2016) was Software Development Process (SDP) and Artificial Intelligence (AI). AI is perhaps my leading choice for best class in program. The lectures provide a good grounding in the basics, not shying away from getting hands dirty with the math. The programming projects were impressive in their depth. Most offered some sort of "challenge" aspect where you could compete with your classmates. One example of this was an agent to play a game. You could enter your agent into the contest and see if it outperformed your classmates. From this, I saw again how skilled many of my classmates were, with some impressive numbers being put on the scoreboard. I learned something from every single exercise in this class, and I feel that it has greatly improved not only my knowledge of AI, but of Bayesian statistics and graph search techniques as well.

SDP was a bit more pedestrian, being a basic overview of software development techniques, ranging from gather requirements, planning, project management, testing, and version control. The biggest graded component was a couple of group projects. While I had great group members, group projects with ad hoc distributed groups are inherently difficult. I did learn from this class (mostly about Android), but it was nowhere near the mind opening experience that AI was.

## The End?

After taking a summer off (a much needed break), I'm just starting what I plan to be my last semester in the program, taking Data and Visual Analytics (DVA) and Introduction to Health Informatics. If these go well, I will graduate in December.

Being so near the end, I find myself reflecting on the worth of the program. Without a doubt, I am a more knowledgeable developer than I was when I started the program. I've gone deeper with tough concepts than I ever would have via self study. I've also made some connections with fellow students, though none as deep as I did during my undergraduate studies. Did I learn as much as I would have with a traditional on-campus, thesis based program? Given the part time nature of the program and the lack of a capstone thesis type project, I would guess that I don't have the same depth of knowledge as I would have gained going that route. However, I have still learned an incredible amount, all the while being able to keep working full time. I also think I learned as much or more than I would have from an on-campus course based program, due to the ability to customize the learning environment to my needs.

OMSCS has been a lot of work, and many tough nights and weekends, but being so near the end and looking back, I am incredibly thankful for the experience and opportunity the program has given me.
